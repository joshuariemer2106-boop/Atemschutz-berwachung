import argparse
import json
import os
from pathlib import Path

import requests
from dotenv import load_dotenv


def read_json_file(path):
    if not path.exists():
        return []
    with path.open("r", encoding="utf-8") as fh:
        data = json.load(fh)
    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        return [data]
    return []


def to_sql_literal(value):
    text = json.dumps(value, ensure_ascii=False, indent=2)
    return f"$json$\n{text}\n$json$::jsonb"


def write_seed_sql(base_dir, out_path, payloads):
    lines = []
    lines.append("-- Generated by scripts/sync_supabase.py")
    lines.append("create table if not exists app_kv (")
    lines.append("  key text primary key,")
    lines.append("  value jsonb not null default '[]'::jsonb")
    lines.append(");")
    lines.append("")
    lines.append("delete from app_kv where key in ('press_users','press_servers','press_settings','press_articles');")
    lines.append("")
    for key, value in payloads.items():
        lines.append(f"insert into app_kv(key, value) values ('{key}', {to_sql_literal(value)});")
        lines.append("")
    Path(out_path).write_text("\n".join(lines), encoding="utf-8")
    print(f"SQL seed written: {Path(out_path).resolve()}")


def sync_to_supabase(url, key, table, payloads):
    endpoint = f"{url.rstrip('/')}/rest/v1/{table}"
    headers = {
        "apikey": key,
        "Authorization": f"Bearer {key}",
        "Content-Type": "application/json",
        "Prefer": "resolution=merge-duplicates,return=minimal",
    }
    for k, v in payloads.items():
        resp = requests.post(
            endpoint,
            headers=headers,
            params={"on_conflict": "key"},
            data=json.dumps([{"key": k, "value": v}], ensure_ascii=False),
            timeout=20,
        )
        if resp.status_code not in (200, 201, 204):
            raise RuntimeError(f"Failed syncing {k}: {resp.status_code} {resp.text}")
        print(f"Synced {k} ({len(v) if isinstance(v, list) else 1})")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--sql-only", action="store_true")
    parser.add_argument("--sql-out", default="supabase_seed.sql")
    args = parser.parse_args()

    load_dotenv()
    base_dir = Path(__file__).resolve().parents[1]
    payloads = {
        "press_users": read_json_file(base_dir / "press_users.json"),
        "press_servers": read_json_file(base_dir / "press_servers.json"),
        "press_settings": read_json_file(base_dir / "press_settings.json"),
        "press_articles": read_json_file(base_dir / "press_articles.json"),
    }

    write_seed_sql(base_dir, base_dir / args.sql_out, payloads)
    if args.sql_only:
        return

    url = (os.getenv("SUPABASE_URL") or "").strip()
    service_key = (os.getenv("SUPABASE_SERVICE_ROLE_KEY") or "").strip()
    table = (os.getenv("SUPABASE_TABLE") or "app_kv").strip() or "app_kv"
    if not url or not service_key:
        raise RuntimeError(
            "Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY in .env. "
            f"SQL file was generated: {args.sql_out}"
        )

    sync_to_supabase(url, service_key, table, payloads)
    print("Supabase sync finished.")


if __name__ == "__main__":
    main()
